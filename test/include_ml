#use "topfind.camlp5";;
#require "compiler-libs.common" ;;
#require "camlp-streams";;
#require "oUnit";;
#require "fmt";;
#require "rresult";;
#require "pcre";;
#require "bos";;
#require "str";;


#require "camlp5.pa_op";;
Pcaml.inter_phrases := Some ";;\n";;
(*
#require "camlp5.pa_r";;
Pcaml.inter_phrases := Some ";\n";;
 *)

#require "camlp5.pr_o";;
module Pr = Pr_o ;;

(*
#require "camlp5.pr_r";;
Pcaml.inter_phrases := Some ";\n";;
module Pr = Pr_r ;;
 *)
#require "camlp5.quotations" ;;

#require "pa_ppx.utils";;
open Pa_ppx_utils.Std ;;

#require "pa_ppx.testutils" ;;
open Pa_ppx_testutils.Papr_util ;;

#require "pa_ppx.base";;
Pa_ppx_base.Pp_MLast.Ploc.pp_loc_verbose := true ;;
let pp_loc = Pa_ppx_base.Pp_MLast.Ploc.pp Fmt.stdout ;;
#install_printer pp_loc ;;

#print_length 1048576 ;;
#print_depth 1048576 ;;
let pp_stream_length = ref 1024 ;;
pp_stream_length :=  1024 ;;
let pp_token_stream strm =
  let l = Stream.npeek !pp_stream_length strm in
  let rec trim_eoi = function
    ("EOI",_ as x)::_ -> [x]
  | h::t -> h::(trim_eoi t)
  | [] -> []
  in 
  Fmt.(pf stdout "<strm<[%a]>>" (list ~sep:comma (parens (pair ~sep:comma (quote string) (quote string)))) (trim_eoi l))
;;
#install_printer pp_token_stream ;;

let pp_ctyp ty = Fmt.(pf stdout "#<ctyp< %s >>" (Eprinter.apply Pcaml.pr_ctyp Pprintf.empty_pc ty));;
let pp_expr ty = Fmt.(pf stdout "#<expr< %s >>" (Eprinter.apply Pcaml.pr_expr Pprintf.empty_pc ty));;
let pp_module_expr ty = Fmt.(pf stdout "#<module_expr< %s >>" (Eprinter.apply Pcaml.pr_module_expr Pprintf.empty_pc ty));;
let pp_module_type ty = Fmt.(pf stdout "#<module_type< %s >>" (Eprinter.apply Pcaml.pr_module_type Pprintf.empty_pc ty));;
let pp_patt ty = Fmt.(pf stdout "#<patt< %s >>" (Eprinter.apply Pcaml.pr_patt Pprintf.empty_pc ty));;

let pp_str_item ty = Fmt.(pf stdout "#<str_item< %s >>" (Eprinter.apply Pcaml.pr_str_item Pprintf.empty_pc ty));;
let pp_sig_item ty = Fmt.(pf stdout "#<str_item< %s >>" (Eprinter.apply Pcaml.pr_sig_item Pprintf.empty_pc ty));;
let pp_attribute_body ty = Fmt.(pf stdout "#<attribute_body< %s >>" (Eprinter.apply Pr.pr_attribute_body Pprintf.empty_pc ty));;

(*
let pp_ctyp ty = Fmt.(pf stdout "#<ctyp< %a >>" Pa_ppx_base.Pp_MLast.pp_ctyp ty);;
let pp_expr ty = Fmt.(pf stdout "#<expr< %a >>" Pa_ppx_base.Pp_MLast.pp_expr ty);;
let pp_patt ty = Fmt.(pf stdout "#<patt< %a >>" Pa_ppx_base.Pp_MLast.pp_patt ty);;
*)

#install_printer pp_ctyp ;;
#install_printer pp_expr ;;
#install_printer pp_module_expr ;;
#install_printer pp_module_type ;;
#install_printer pp_patt ;;
#install_printer pp_str_item ;;
#install_printer pp_sig_item ;;

#require "pa_llk_compiler" ;;
#require "pa_llk_runtime" ;;
open Parse_gram ;;
open Print_gram ;;
open Comp_llk ;;
open Llk_regexps ;;

let pp_regexp_ast e = Fmt.(pf stdout "<:regexp_ast< %s >>" (Pr.pr_regexp_ast Pprintf.empty_pc e)) ;;
#install_printer pp_regexp_ast ;;

let pp_regexp e = Fmt.(pf stdout "<:regexp< %s >>" (PSyn.print e)) ;;
#install_printer pp_regexp ;;

let pp_a_entry e = Fmt.(pf stdout "<:entry<%s>>" (Pr.entry Pprintf.empty_pc e)) ;;
#install_printer pp_a_entry ;;

let pp_a_level e = Fmt.(pf stdout "<:level<%s>>" (Pr.level false Pprintf.empty_pc e)) ;;
#install_printer pp_a_level ;;

let pp_a_symbol e = Fmt.(pf stdout "<:symbol<%s>>" (Pr.symbol Pprintf.empty_pc e)) ;;
#install_printer pp_a_symbol ;;

let pp_a_psymbol e = Fmt.(pf stdout "<:psymbol<%s>>" (Pr.psymbol Pprintf.empty_pc e)) ;;
#install_printer pp_a_psymbol ;;

let pp_a_rule e = Fmt.(pf stdout "<:rule<%s>>" (Pr.rule true Pprintf.empty_pc e)) ;;
#install_printer pp_a_rule ;;

let pp_cg (cg : CG.t) = Fmt.(pf stdout "<cg>") ;;
#install_printer pp_cg ;;

(* ================================================================ *)

(*
let ast1 = RT.pa_regexp_ast {| "rec"? ( UIDENT | "_" | $_uidopt | $uidopt) (":" | "(") #4|} ;;
let re1 = normalize_astre []  ast1;;
let ast2 = RT.pa_regexp_ast {| (UIDENT | $uid | $_uid) ":=" #3 |} ;;
let re2 = normalize_astre []  ast2;;
let re3 = PSyn.disjunction [re1; re2] ;;


module X0 = Compile(struct
  let rex = PSyn.epsilon
  open PatternBaseToken ;;
  let extra = [CLS "UIDENT";
 SPCL "_";
 SPCL "rec";
 ANTI "_uidopt";
 ANTI "uidopt"] end) ;;
 *)

(*
let re =  {|  (UIDENT | $uid | $_uid) ":=" #3 | "alias" #0 | "type" #1 | (eps | "rec") (UIDENT | "_" | $_uidopt | $uidopt) (":" | "(") #2 |} |> Stream.of_string |> Grammar.Entry.parse Pa.regexp |> normalize_astre [] ;;

module X = Compile(struct let rex = re let extra = [] end) ;;

X.BEval.OutputDfa.(dump ~rexlabels:false stdout (dfa re)) ;;

#trace X.BEval.nullable ;;
#trace X.BEval.delta ;;
#trace X.BEval.nonempty ;;
#trace X.BEval.OutputDfa.may_have_successors ;;
#trace X.BEval.OutputDfa.failed_state ;;
#trace X.BEval.OutputDfa.final_state ;;
#trace X.BEval.OutputDfa.internal_error_state ;;
#trace X.BEval.OutputDfa.watch_regexp ;;
#trace X.BEval.OutputDfa.dfa ;;
 *)


#load "original_rtest.cmo";;
#require "camlp5.pr_official";;
#load "papr_test_matrix.cmo";;
#load "llko2official_test.cmo" ;;
open Original_rtest ;;
open Llko2official_test ;;
#trace Original.F.implem ;;
#trace Original.F.str_item ;;
#trace Original.F.str_item__0001;;
#trace Original.F.str_item__0001__268 ;;
#trace Original.F.first_let_binding ;;
#trace Original.F.first_type_decl ;;
#trace Original.F.type_kind ;;
#trace Original.F.type_kind_regexp ;;
#trace Original.F.constructor_declaration ;;
#trace Original.F.rest_constructor_declaration ;;
#trace Original.F.cons_ident ;;
#trace Original.F.ctyp_ident ;;
#trace Original.F.fun_binding ;;
#trace Original.F.ctyp ;;
#trace Original.F.ctyp__0003 ;;
#trace Original.F.expr_longident ;;
#trace Original.F.expr ;;
#trace Original.F.paren_module_expr ;;
#trace Original.F.module_expr ;;
#trace Original.F.longident ;;
#trace Original.F.longident__0002 ;;
#trace Original.F.longident__0001__227 ;;
#trace Original.F.type_extension ;;
#trace Original.F.str_item__0001__271 ;;
#trace Original.F.extended_longident ;;
#trace Original.F.extended_longident__0002 ;;
#trace Original.F.extended_longident__0001__203 ;;
#trace Original.F.str_item__0001__271_regexp ;;
#trace Original.F.poly_type ;;
#trace Original.F.sig_item ;;
#trace Original.F.module_type ;;
#trace Original.F.expr__0020 ;;
#trace Original.F.ext_attributes ;;
#trace Original.F.expr__0020__198 ;;
#trace Original.F.class_signature ;;
#trace Original.F.class_sig_item ;;
#trace Original.F.ext_opt ;;
#trace Original.F.class_description ;;
#trace Original.F.alg_attributes_no_anti ;;
#trace Original.F.class_type_parameters ;;
#trace Original.F.class_type ;;
#trace Original.F.class_type__0001 ;;
#trace Original.F.class_type__0001__166 ;;
#trace Original.F.class_type__0001__339 ;;
#trace Original.F.letop_binding ;;


(*
#load "regexp_test.cmo";;
open Regexp_test ;;

#load "simple_otest.cmo";;
open Simple_otest ;;

#load "external_test.cmo";;
open External_test ;;
 *)


(*
;;; Local Variables: ***
;;; mode:tuareg ***
;;; End: ***

*)
(*
#trace Follow.watch_follow ;;
#trace Follow.comp1_entry ;;
#trace Follow.fifo_symbol ;;
#trace Follow.fifo_psymbols ;;
#trace Follow.fifo_rule ;;
#trace Follow.fifo_level ;;
#trace CG.add_follow ;;
#trace CG.follow ;;
"original_rtest.ml" |> RT.read_file |> PAPR.Implem.pa1 |> PAPR.Implem.pr |> print_string ;;
 *)

(*
let cg = {|
GRAMMAR Neg:
EXPORT: e;
REGEXPS:
  check_not_let = ~"let" & _* ;
END ;
  e: [ [ "let" ; s = STRING -> Right ("let "^s)
       | check_not_let ; e = e1 -> e1 ] ] ;

  e1:
    [
      [ "let" ; s = STRING  -> Right s
      | n = INT -> Left n
      ]
    ]
  ;
END;

|} |> Top.normre ~bootstrap:true Ploc.dummy ;;
module DC = DebugCompile(struct let rexs = {|  "let" #0 | (~"let" & _* ) #1 |} let cg = cg end) ;;
 *)
